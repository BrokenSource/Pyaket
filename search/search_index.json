{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Pyaket \ud83d\udce6 Easy Python to \u2192 Fast Executables \ud83d\udce6      Links \u2022     Installation \u2022     Examples \u2022     Documentation \u2022     Issues <sub> GitHub \u2022     Contact \u2022     Changelog \u2022     License </sub>"},{"location":"#description","title":"\ud83d\udd25 Description","text":"<p>\ud83d\udce6 Pyaket is a tool that bundles and generates portable executables of your python projects for all platforms. No more convoluted installation steps, give users the convenience they want, with maximum compatibility and dev-centric ease of use compared to alternative solutions.</p> <ul> <li> Lightning fast installation that automatically manages python, virtual environments, and dependencies without user intervention that just works, bundle wheels or install from pypi.</li> <li> Max compatibility with how the project is run in the user's machine - pyaket does not reinvent the wheel or compile python with an intermediate, use tools that already exists #</li> <li> Cross compile from anywhere to most platforms and architectures, no docker or virtual machines required, portable immutable executables - see the table for details! #</li> <li> Intelligently detects partial installations, downloads, archive unpacks, and automatically takes appropriate action - making iterative development easy and resilient against users</li> <li> Standalone executables with no network calls at runtime that bundles all dependencies #</li> <li> Monorepo support in mind, decoupled dependencies and entry point specification</li> <li> Rolling releases where a single binary always runs latest pypi or git branch/tag #</li> <li> PyTorch installation at runtime, automatic backend detection (optional). #</li> </ul>"},{"location":"#examples","title":"\u2b50\ufe0f Examples","text":""},{"location":"#simple-to-use","title":"Simple to use","text":"<p>Compile a cowsay binary for the current platform and run it:</p> <pre><code>$ pyaket app --name cowsay --pypi \"cowsay==6.1\" run --module cowsay compile\n  Compiling libc v0.2.172\n  Compiling typenum v1.18.0\n  ...\n  Finished `release` profile [optimized] target(s) in 9.88s\n</code></pre> <pre><code>$ ./release/cowsay-linux-amd64-v0.0.0.bin -t \"Hello, Pyaket!\"\n  ______________\n| Hello, Pyaket! |\n  ==============\n     \\\n      \\\n        ^__^\n        (oo)\\_______\n        (__)\\       )\\/\\\n            ||----w |\n            ||     ||\n</code></pre>"},{"location":"#fast-iterative-development","title":"Fast iterative development","text":"<p>with a warm build cache:</p> <pre><code>$ pyaket app -n cowsay -p \"cowsay==6.1\" run -m cowsay compile\n  Finished `release` profile [optimized] target(s) in 1.54s\n</code></pre>"},{"location":"#blazingly-fast","title":"Blazingly fast","text":"<p>after the first installation:</p> <pre><code>$ hyperfine \"./release/cowsay-linux-amd64-v0.0.0.bin -t anyhow\"\n  Time (mean \u00b1 \u03c3):      23.3 ms \u00b1   0.3 ms    [User: 15.8 ms, System: 7.2 ms]\n  Range (min \u2026 max):    22.9 ms \u2026  24.8 ms    100 runs\n\n$ hyperfine \"python -m cowsay -t anyhow\"\n  Time (mean \u00b1 \u03c3):      18.5 ms \u00b1   0.1 ms    [User: 14.2 ms, System: 4.1 ms]\n  Range (min \u2026 max):    18.2 ms \u2026  19.0 ms    100 runs\n</code></pre> <p><sup>Note: For the keen among you, the actual benchmark command was <code>nice -20 taskset -c 2 hyperfine -w 50 -r 100 -N (...)</code>, executed on Python 3.13.3, mainline Linux kernel v6.14.4, R9 5900x ondemand governor stock, 2x3200 MT/s DDR4 CL16 2Rx8 as of May 2025</sup></p>"},{"location":"#cross-compile","title":"Cross compile","text":"<p>to most platforms and architectures easily:</p> <pre><code># Windows executables compiled from linux\n$ pyaket app -n cowsay -p \"cowsay==6.1\" run -m cowsay release -t windows compile\n  Finished `release` profile [optimized] target(s) in 8.11s\n\n$ wine ./Release/cowsay-windows-amd64-v0.0.0.exe -t \"Hello, Wine!\"\n  ____________\n| Hello, Wine! |\n  ============\n            \\\n             \\\n               ^__^\n               (oo)\\_______\n               (__)\\       )\\/\\\n                   ||----w |\n                   ||     ||\n</code></pre> <pre><code># Intel Macbook @ ./release/cowsay-macos-amd64-v0.0.0.bin\n$ pyaket ... release --target macos --arch amd64 compile\n\n# Apple Silicon @ ./release/cowsay-macos-arm64-v0.0.0.bin\n$ pyaket ... release --target macos --arch arm64 compile\n</code></pre>"},{"location":"#bundle-wheels","title":"Bundle wheels","text":"<p>and install them at runtime, perfect for monorepos:</p> <pre><code>$ uv build --all-packages --wheel -o dist\n  Successfully built dist/shared-1.0.0-py3-none-any.whl\n  Successfully built dist/project_a-1.0.0-py3-none-any.whl\n  Successfully built dist/project_b-1.0.0-py3-none-any.whl\n\n# Both will share the same virtual environment \ud83e\udd2f\n# ./release/{project_a,project_b}-linux-amd64-v0.0.0.bin\n$ pyaket app -n project_a -w \"dist/*.whl\" run -m project_a compile\n$ pyaket app -n project_b -w \"dist/*.whl\" run -m project_b compile\n</code></pre>"},{"location":"#install-pytorch","title":"Install pytorch","text":"<p>at runtime, with automatic backend detection:</p> <pre><code># ./release/app-linux-amd64-v0.0.0-auto.bin\n$ pyaket ... torch -v 2.7.0 -b auto compile\n\n# ./release/app-linux-amd64-v0.0.0-cu128.bin\n$ pyaket ... torch -v 2.7.0 -b cu128 compile\n</code></pre>"},{"location":"#more-examples","title":"More examples","text":"<p>For more examples, proper configuration and advanced features, check out the website page!</p> <p> </p>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>For now, Pyaket is only available when installing from source:</p> <pre><code>python3 -m pip install git+https://github.com/BrokenSource/Pyaket[cross]\n</code></pre> <p>In the future, you'll be able to install from pypi, or crates.io for pure rust usage.</p>"},{"location":"#community","title":"\u267b\ufe0f Community","text":"<p><sup>\u2705 Be featured here if you're using Pyaket in your projects!</sup></p> <p>\ud83c\udf35 Such an empty place here, for now..</p>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#0.9.0","title":"\u270f\ufe0f v0.9.0 Unreleased","text":"<ul> <li>Initial version, will match the monorepo due heavy integration and use of already existing infrastructure</li> </ul>"},{"location":"about/contact/","title":"About/Contact","text":"<ul> <li> <p> Discord <p>Largest community, fastest responses</p> <ul><li>Priority sponsors support</li></ul> Join Server</p> </li> <li> <p> GitHub <p>Officialize your Requests or Issues</p> <ul><li>One repository per project</li></ul> All Projects</p> </li> <li> <p> Telegram <p>Also an option if you prefer over others!</p> <ul><li>Larger uploads can be useful</li></ul> Join Group</p> </li> <li> <p> Email <p>Get in touch directly and privately</p> <ul><li>Business or Traditional</li></ul> Send a Message</p> </li> </ul> <p>I live on the UTC-04:00 Timezone (EDT), so I might be sleeping when you send me a message</p> <p>Feel free to talk in any of the Languages: \ud83c\udde7\ud83c\uddf7 \ud83c\uddfa\ud83c\uddf8</p>"},{"location":"about/credits/","title":"Credits","text":"<p>\ud83d\udea7 Work in progress \ud83d\udea7</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#project","title":"Project","text":"<p>Pyaket is free to use for any project under Open Source Initiative Approved Licenses that shares fully featured releases at no cost (Free Projects). Similar to compilers and other tools, it does not require your project to also be AGPLv3 licensed to use it, except for changes to the code itself.</p> <ul> <li>No strings attached, we're both free and open source software for the cause!</li> <li>Share the word by linking or attributing the project if it helped you out \ud83d\ude80</li> </ul> <p>Commercial use, including but not limited to selling executables, for-profit deployments, bundling proprietary software, internal use without distribution requires a sponsorship tier. You may freely evaluate the viability beforehand, or use it to get started<sup>1</sup> under a limited budget or uncertainty. Subscriptions are recommended for continuous long-term support by sharing a tiny fraction of the revenue, so both sides can grow. Get in touch for custom agreements, questions, discounts, grants, features you'd need to make it work for you, or anything else really.</p> <ul> <li>To make it extra fair, I'll split the revenue with the most important dependencies and libraries that pyaket wouldn't be possible without \u2022 see the credits page for more details.</li> </ul> <p>The code is licensed under the AGPLv3 terms - a strong copyleft license to ensure it remains free and open source for all users. You may get in touch for a custom agreement to lift restrictions of the license to extend it privately. Contributions rights are transferred to the project authors<sup>2</sup>.</p> <p> This was a rough decision to open-source it at all. I have no intent to limit or restrict the use of my work, but it must be sustainable and target the businesses that shall profit a lot from it.</p>"},{"location":"about/license/#dependencies","title":"Dependencies","text":"<p>Thanks to cargo-deny and my strict configuration for only permissive licenses, no part of the rust code links to or uses proprietary or viral libraries. The python part uses minimal dependencies and was also checked, although manually - check the credits page for an exhaustive list.</p> <p> However, for purely functional reasons, third party tools are downloaded and used at runtime, or bundled in the executable, such as astral-sh/uv and astral-sh/python-buid-standalone.</p> <p>Pyaket is not responsible for developer-specified dependencies and their projects under any circumstances and legal terms, and cannot be held liable for any violations.</p> <ol> <li> <p>While entry tiers are affordable, you may choose to sponsor later, using only the revenue generated by your project.\u00a0\u21a9</p> </li> <li> <p>With enough stable support, I plan on transferring Pyaket to a permissive license in the future. Such feat would be hard to coordinate with contributors holding copyrights on the codebase - I will not make the project proprietary.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/roadmap/","title":"Roadmap","text":"<p>     Click here to see the Roadmap on GitHub Projects </p>"},{"location":"docs/","title":"Configuration","text":"<p> \ud83d\udce6 Pyaket's configuration is done via environment variables read by rust at compile time, which are processed and passed through to the executable to load at runtime.</p> <p>This page documents all  Rust side environment variables and extra information. You don't need the Python package to build a Pyaket executable if you're skilled with cargo, although most of these have python cognates and follows the same structure seen here.</p> <p>Some settings are exclusive to python</p> <ul> <li>The <code>--upx</code> flag can't currently be supported by the rust side yet, as cargo lacks post-build hooks. You can do it yourself though, finding the binary at <code>target/*/pyaket</code> and running <code>upx</code> on it.</li> <li>The <code>--standalone</code> flag is a syntatic sugar for other options; exporting all deps wheels is annoying in rust.</li> </ul> <p></p>"},{"location":"docs/#app","title":"Application","text":"<p> General metadata of the project</p>"},{"location":"docs/#app-name","title":"PYAKET_APP_NAME","text":"<p>\ud83d\udce6 Type: String \u2022 Default: Application</p> <p>The name of the application being built.</p> <p>Currently only used for identifying \u2022 flagging successfull installations and recreating the virtual environment shall the binary hash changes. This is purely useful for iterative development.</p>"},{"location":"docs/#app-author","title":"PYAKET_APP_AUTHOR","text":"<p>\ud83d\udce6 Type: String \u2022 Default: brokensrc</p> <p>The author's name, group, organization of the application being built.</p> <p>The value is mostly used for dictating the workspace root when dynamic. Centralizes installation paths and caches for a given author, while being independent enough to not interfere with others.</p>"},{"location":"docs/#app-version","title":"PYAKET_APP_VERSION","text":"<p>\ud83d\udce6 Type: String \u2022 Default: 0.0.0</p> <p>The version of the application being built.</p> <p>Should follow the version of the project to be released alonside a registry itself. Not necessarily a semantic version, can be a codename, branch, latest, etc. Value is added to versions dir, building the full installation path of the venv to be used.</p> <p>To get the current version in python, use:</p> <pre><code>from importlib.metadata import version as get_version\n\nversion = get_version(\"package\")\n</code></pre> <p>Or better yet, if using Hatch, define a <code>__version__</code> at <code>__init__.py</code> and use in <code>pyproject.toml</code>:</p> <pre><code>[tool.hatch.version]\npath = \"package/__init__.py\"\n\n[project]\ndynamic = [\"version\"]\n</code></pre> <p></p>"},{"location":"docs/#dependencies","title":"Dependencies","text":"<p> A continuation of the application section for listing dependencies.</p>"},{"location":"docs/#app-wheels","title":"PYAKET_APP_WHEELS","text":"<p>\ud83d\udce6 Type: Paths \u2022 Default: None</p> <p>Glob patterns separated by <code>;</code> (semi colon) of wheels and sdists to bundle and install at runtime.</p> Example<pre><code>export PYAKET_APP_WHEELS=\"/path/to/wheel1.whl;/path/to/wheel2.whl\"\nexport PYAKET_APP_WHEELS=\"/path/to/*.whl;/other/*.whl\"\nexport PYAKET_APP_WHEELS=\"/path/to/sdists/*.tar.gz\"\n</code></pre> <p>Paths must be absolute, as they are relative to <code>build.rs</code></p> <p>This is the recommended way to specify dependencies, although third party packages may still be installed at runtime, comparing to PyPI. If we get them all, a standalone install is achieved, with zero network calls to get missing packages at cost of large binary size.</p> <ul> <li>Beware that sdists may need compilation at runtime in the user's machine, prefer wheels.</li> <li>If you have a monorepo with uv, it's as simple as <code>uv build --all</code> and include <code>dist/*</code>.</li> <li>This option allows to bundle private wheels without pushing to a registry.</li> </ul> <p>\u2705 This is the recommended way to specify dependencies</p>"},{"location":"docs/#app-pypi","title":"PYAKET_APP_PYPI","text":"<p>\ud83d\udce6 Type: String \u2022 Default: None</p> <p>List of PyPI packages to be installed at runtime, separated by <code>;</code> (semi colon).</p> Example<pre><code># Regular dependencies, latest version\nexport PYAKET_APP_PYPI=\"numpy;plotly;pillow\"\n\n# Specific stable version of a package\nexport PYAKET_APP_PYPI=\"shaderflow==0.9.0\"\n\n# Or even git dependencies, targetting specific branches or tags\nexport PYAKET_APP_PYPI=\"git+https://github.com/BrokenSource/DepthFlow\"\nexport PYAKET_APP_PYPI=\"git+...@develop\"\nexport PYAKET_APP_PYPI=\"git+...@v1.0.0\"\n</code></pre> <p>This option is partially recommended, as it requires a network download at runtime and pushing to a registry for iterative development. Bundling wheels is often a better option if binary size is not a concern, you can test with wheels first then push a stable version to a registry too.</p>"},{"location":"docs/#app-requirements-txt","title":"PYAKET_APP_REQTXT","text":"<p>\ud83d\udce6 Type: Local Path \u2022 Default: None</p> <p>A local <code>requirements.txt</code> file to be installed at runtime.</p> <p>This option mostly exists for legacy reasons. You really should move to a <code>pyproject.toml</code> as it allows easier build backends to create portable wheels for your project that includes your code. The only use I can think of is to run a project-less script with a requirements file alongside it.</p>"},{"location":"docs/#app-rolling","title":"PYAKET_APP_ROLLING","text":"<p>\ud83d\udce6 Type: Bool \u2022 Default: False</p> <p>Always reinstall the project's dependencies when running the executable.</p> <p>This option is best combined with a <code>git+</code> dependency or <code>package</code> without a <code>==version</code> specifier, to create a one-time binary that self-updates. This is obviously discouraged for any production use, unless very controlled, or in ephemeral runtimes for a couple of reasons:</p> <ul> <li>Security: Any malicious update (on the developer or third party side) will be downloaded and executed on the user's/your machine, blindly, without a way to recall.</li> <li>Performance: The executable will be slower to start and require mandatory network calls at every run, which could give a temporary IP ban if abusing the registry.</li> <li>Stability: The dependencies may change and break the project.</li> </ul> <p>A valid, but unconventional, use case is to pin all your dependencies to a specific version and target your latest stable PyPI releases (or git main branch) for clients after heavy testing.</p> <p></p>"},{"location":"docs/#entry-points","title":"Entry Points","text":"<p> This section is about the entry points of the executable run after the installation.</p> <ul> <li>At least one entry point is required, otherwise it'll boot to the Python shell.</li> <li>All incoming args of the executable are passed through to the final command.</li> </ul>"},{"location":"docs/#entry-module","title":"PYAKET_ENTRY_MODULE","text":"<p>\ud83d\udce6 Type: String \u2022 Default: None</p> <p>A module's name to be called as <code>python -m &lt;module&gt; (args)</code> after installation.</p> <ul> <li>The file <code>&lt;module&gt;/__main__.py</code> must exist, otherwise it will error out.</li> </ul> <p>\u2705 This is the recommended and reliable way to run your project, have a top-level cli for multiple entries</p>"},{"location":"docs/#entry-script","title":"PYAKET_ENTRY_SCRIPT","text":"<p>\ud83d\udce6 Type: String \u2022 Default: None</p> <p>A local script to be bundled and called as <code>python &lt;script.py&gt; (args)</code> after installation.</p>"},{"location":"docs/#entry-code","title":"PYAKET_ENTRY_CODE","text":"<p>\ud83d\udce6 Type: String \u2022 Default: None</p> <p>An inline Python code to be executed as <code>python -c &lt;code&gt; (args)</code> after installation.</p> <ul> <li>Slightly more reliable than an entry script, as it doesn't write a temp file.</li> <li>Less flexible and readable because it must be a single line of code.</li> </ul>"},{"location":"docs/#entry-command","title":"PYAKET_ENTRY_COMMAND","text":"<p>\ud83d\udce6 Type: String \u2022 Default:f None</p> <p>A command to be executed as <code>&lt;command&gt; (args)</code> after installation.</p> <ul> <li>The venv is activated and the bin directory is added to PATH, so this can be a script defined in your <code>pyproject.toml</code> \u2022 <code>[project.scripts]</code> section.</li> </ul> <p>It may be used if you have multiple entry points, like <code>depthflow {main,gradio}</code>, and want to hardcode pin one to be used, or set fixed arguments to some command.</p> <p>Discouraged: Security implications, man in the middle attack, may use wrong command</p> <p></p>"},{"location":"docs/#dirs","title":"Directories","text":"<p> Directories used by Pyaket to store the application data.</p>"},{"location":"docs/#workspace","title":"WORKSPACE","text":"<p>\ud83d\udce6 Type: Path \u2022 Default: Dynamic</p> <p>The workspace root directory Pyaket will use for the project.</p> <p>This is a special variable that can be overriden at runtime and is dynamic if unset. By default, Pyaket uses proper and intended platform directories to store the application data:</p> <p>  Windows C:\\Users\\User\\AppData\\Local\\Author  MacOS ~/Library/Application Support/Author  Linux ~/.share/Author </p> <p>Shall a user set it, the value is used as is. This is especially useful if folks have a full C:\\ drive or want a custom directory than the above for large application data. A Python project should follow the same pattern, so all files are in the same place for easier uninstallation.</p> Example<pre><code>$ export WORKSPACE=\"/tmp/workspace\"\n$ ./pyaket-project.bin\n</code></pre>"},{"location":"docs/#common-dir","title":"PYAKET_COMMON_DIR","text":"<p>\ud83d\udce6 Type: Path \u2022 Default: Pyaket</p> <p>The subdirectory of the workspace to use for all Pyaket installation and runtime files.</p> <p>By default, things are stored in a <code>Pyaket</code> directory (due lack of a better name). All other internal directories derives from this one. It can be left empty if you'll not use platformdirs yourself.</p> <p>  Windows C:\\Users\\User\\AppData\\Local\\Author\\Pyaket  MacOS ~/Library/Application Support/Author/Pyaket  Linux ~/.share/Author/Pyaket  Custom Workspace/Pyaket </p> <p>You may find the following directories inside the composition:</p> <ul> <li>Astral: Stores uv versions, archives and unpacked files.</li> <li>Cache: Used for <code>UV_CACHE_DIR</code>, primarily package download caches.</li> <li>Python: Stores multiple versions of Python distributions.</li> <li>Versions: See versions dir for more details.</li> </ul>"},{"location":"docs/#versions-dir","title":"PYAKET_VERSIONS_DIR","text":"<p>\ud83d\udce6 Type: String \u2022 Default: Versions</p> <p>The subdirectory of the common directory to install the virtual environments.</p> <p>Multiple versions of the same application(s) are stored in a shared directory (venv). From the table below, <code>(...)</code> is replaced with the version, yielding the full installation path.</p> <p>  Windows C:\\Users\\User\\AppData\\Local\\Author\\Pyaket\\Versions\\(...)  MacOS ~/Library/Application Support/Author/Pyaket/Versions/(...)  Linux ~/.share/Author/Pyaket/Versions/(...)  Custom Workspace/Pyaket/Versions/(...) </p> <ul> <li>Note: Applications of an author that shares the same versions dir must be coupled together. If they are independent, a workaround is to set this value to <code>Versions/&lt;app_name&gt;</code>, so each application have a separate versions directory. Default is shared for monorepos in mind.</li> </ul> <p></p>"},{"location":"docs/#python","title":"Python","text":"<p> This section is about the Python interpreter to be used at runtime.</p>"},{"location":"docs/#python-version","title":"PYAKET_PYTHON_VERSION","text":"<p>\ud83d\udce6 Type: Version string \u2022 Default: 3.13</p> <p>The version of Python to be used at runtime, from astral-sh/python-build-standalone.</p> <ul> <li> <p>Note: Specific versions support, such as <code>3.10.17</code>, depends on the uv-version in use, as the URLs are hard-coded in their binary. For example, <code>3.13.3</code> was added in v0.6.14.</p> </li> <li> <p>Please chose carefully to ensure all your wheels and dependencies are compatible with the target version. Users may not have compilers and headers for sdists.</p> </li> </ul>"},{"location":"docs/#python-bundle","title":"PYAKET_PYTHON_BUNDLE","text":"<p>\ud83d\udce6 Type: Bool \u2022 Default: False</p> <p>Whether to embed the python distribution in the executable, instead of a runtime download.</p> <p>Having this enabled increases binary size by roughly 20 MB, but greatly increases reliability and improves first startup times. However, it may trigger antivirus heuristics on giving false positives, as it is a sketchy thing to include archives and decompressors in a binary - this is mostly a non-issue Windows only moment. Disabled by default for easy to share small executables.</p> <p>\u26a0\ufe0f Warning: This feature is not yet implemented</p> <p></p>"},{"location":"docs/#uv","title":"UV","text":"<p> This section is about uv, a fast python and project manager, to be used at runtime.</p> <p>Pyaket wouldn't be possible without it, huge kudos to the Astral Team!</p>"},{"location":"docs/#uv-version","title":"PYAKET_UV_VERSION","text":"<p>\ud83d\udce6 Type: Version string \u2022 Default: 0.6.14</p> <p>The version of uv to be used at runtime, from official astral-sh/uv releases.</p> <ul> <li>Note: This value shouldn't really be changed. Older versions may miss features, newer ones might have breaking changes. Pyaket guarantees only the default version to work.</li> </ul>"},{"location":"docs/#uv-bundle","title":"PYAKET_UV_BUNDLE","text":"<p>\ud83d\udce6 Type: Bool \u2022 Default: True</p> <p>Whether to embed the uv distribution in the executable, instead of a runtime download.</p> <p>Having this enabled increases binary size by roughly 20 MB, but greatly increases reliability and improves first startup times. However, it may trigger antivirus heuristics on giving false positives, as it is a sketchy thing to include archives and decompressors in a binary - this is mostly a non-issue Windows only moment. Disabled by default for easy to share small executables.</p> <p></p>"},{"location":"docs/#pytorch","title":"PyTorch","text":"<p>This section covers PyTorch configuration for ML and AI projects.</p> <ul> <li> <p>Note: Will be installed before others, to avoid using a platform default in the dependencies. Pip should skip ok, unless you specify <code>x.y.z==flavor</code>, which errors out.</p> </li> <li> <p>Warn: Version 2.7.0+ with cu128 is required for RTX 5000+ series! [1]</p> </li> </ul>"},{"location":"docs/#torch-version","title":"PYAKET_TORCH_VERSION","text":"<p>\ud83d\udce6 Type: Version string \u2022 Default: None</p> <p>An optional version of PyTorch to be installed at runtime.</p>"},{"location":"docs/#torch-backend","title":"PYAKET_TORCH_BACKEND","text":"<p>\ud83d\udce6 Type: String \u2022 Default: auto</p> <p>The hardware acceleration backend of PyTorch to be installed at runtime.</p> <ul> <li>When set to auto, uv will decide the best one (experimental)</li> <li>Other values will be passed to the <code>--extra-index-url</code> as:</li> </ul> <pre><code>uv pip install torch==${VERSION}$+${BACKEND}\n    --extra-index-url https://download.pytorch.org/whl/${BACKEND}\n</code></pre> <p> The allowed values depends on the PyTorch version. You can check this page for the latest values, and this other page for older ones. ROCm is for AMD GPUs. Use empty for default.</p>"},{"location":"docs/crosscompile/","title":"Crosscompile","text":"<p>Thanks to Rust's amazing toolchain, coupled with cargo-zigbuild, and using pure crates, Pyaket can pretty much compile executables from any platform to any platform without docker or vms.</p> From / To <p> N/A <p> N/A <p> GNU <p> MSVC \ud83d\udc27 Linux x86 \u2705 x86 <p> \u2611\ufe0f Arm \u2611\ufe0f x86 <p> \u2611\ufe0f Arm \u2705 x86 <p> \u274c Arm \ud83d\udeab x86 <p> \ud83d\udeab Arm \ud83d\udc27 Linux Arm \u2753 x86 <p> \u2753 Arm \u2753 x86 <p> \u2753 Arm \u2753 x86 <p> \u274c Arm \ud83d\udeab x86 <p> \ud83d\udeab Arm \ud83d\udca0 Windows x86 \u2705 x86 <p> \u2611\ufe0f Arm \u2611\ufe0f x86 <p> \u2611\ufe0f Arm \u2705 x86 <p> \u2611\ufe0f Arm \u2705 x86 <p> \ud83e\udd0f Arm \ud83d\udca0 Windows Arm \u2753 x86 <p> \u2753 Arm \u2753 x86 <p> \u2753 Arm \u2753 x86 <p> \u2753 Arm \u2753 x86 <p> \u2753 Arm \ud83c\udf4e MacOS x86 \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \ud83d\udeab x86 <p> \ud83d\udeab Arm \ud83c\udf4e MacOS Arm \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \u2714\ufe0f x86 <p> \u2714\ufe0f Arm \ud83d\udeab x86 <p> \ud83d\udeab Arm <p><sup>Note: The table simply states if it compile and/or run. Your Python project may not work on all platforms.</sup></p> <ul> <li>\u2705 Verified and supported</li> <li>\u2611\ufe0f Compiled, but untested</li> <li>\u2714\ufe0f Should work (untested)</li> <li>\u274c Impractical (possible)</li> <li>\ud83d\udeab Impossible</li> </ul>"},{"location":"docs/pinning/","title":"Locking dependencies","text":"<p>It's a good idea to pin all of your wheels dependencies to a specific version for building the executables, to ensure they'll work after any upstream changes.</p> <p>When building the wheels of your project, pyaket sets the environment variable <code>PYAKET_RELEASE</code> to <code>1</code> for detecting whether</p>"},{"location":"docs/pinning/#hatchling","title":"Hatchling","text":"<p>Add a metadata hook in your project like I do with other projects:</p> <p>Note: At least one field must be dynamic to trigger the hook, redefining version is the easiest</p> pyproject.toml<pre><code>[project]\ndynamic = [\"version\"]\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.metadata.hooks.custom]\npath = \"hatch_build.py\"\n</code></pre> <p>Note: Feel free to change where the version is being fetched</p> hatch_build.py<pre><code>import os\nimport runpy\nfrom pathlib import Path\n\nfrom hatchling.metadata.plugin.interface import MetadataHookInterface\n\n\nclass PyaketHook(MetadataHookInterface):\n    def update(self, metadata: dict) -&gt; None:\n        repository = Path(__file__).parent\n\n        # Get the version from the main package\n        context = runpy.run_path(repository/\"package\"/\"__init__.py\")\n        version = metadata[\"version\"] = context[\"__version__\"]\n\n        # Trick to replace all list items in place\n        def patch(items: list[str]) -&gt; None:\n            for (x, item) in enumerate(items):\n                if (os.environ.get(\"PYAKET_RELEASE\", \"0\") == \"1\"):\n                    item = item.replace(\"~=\", \"==\")\n                    item = item.replace(\"&gt;=\", \"==\")\n                items[x] = item\n\n        # Patch all normal and optional dependencies\n        list(map(patch, metadata.get(\"optional-dependencies\", {}).values()))\n        patch(metadata.get(\"dependencies\", {}))\n</code></pre> <p>This doesn't fully guarantee a locked environment as dependencies of dependencies might not be pinned. A better way is to send a <code>uv.lock</code> file, but it kills iterative development.</p> <p> Todo: Improve and find a method without such drawbacks</p>"},{"location":"faq/alternatives/","title":"Alternatives","text":"<p>Pyaket is not the first project solving the packaging problem. Many alternatives out there served as inspiration for the design choices and features of the project, but ultimately none solved my needs and requirements. Here's my thoughts, differences and similarities on each of them - feel free to reach me out if I'm wrong and/or a feature has been added solving any of these!</p> <p><sup>Note: My intention is not to discredit or belittle others, rather similar to literature review in academic papers. These are my subjective opinions and experiences, if anything to contribute back ideas and feedback.</sup></p>"},{"location":"faq/alternatives/#pyapp","title":"PyApp","text":"<p>Hands down the most similar solution and major source of inspiration used up until v0.8 of my projects. Mostly decided to write my own from scratch as many opinionated and idiosyncratic changes I needed were extremely unlikely to be accepted upstream; I had a fork implementing some of them, but it felt cheesy using that much external work for my branding and selling files.</p> <p> Some of the issues I had with it, in order of importance, were:</p> <ul> <li>Expects a single project wheel or pypi dependency, bad monorepo integration and support.</li> <li>No safety against partial installs: Instructing Windows users how to open a powershell in a directory, then typing executable name plus <code>self restore</code> is annoying to say the least.</li> <li>Variable naming schemes are confusing at times, plus there are a lot of them trying to support everything and nothing at the same time, better to limit the scope and sane defaults.</li> <li>Some critical options aren't configurable, such as the installation root directory.</li> </ul>"},{"location":"faq/alternatives/#pyinstaller","title":"PyInstaller","text":"<ul> <li>My main problem is that a <code>--onefile</code> executable needs to fully unpack itself to the system temp directory each run, not only being slow but wearing out SSDs quite quickly.</li> <li>Compatibility is generally nice, but packages needing to bundle shared libraries are often a huge problem</li> </ul>"},{"location":"faq/alternatives/#nuitka","title":"Nuitka","text":"<p>-</p>"},{"location":"faq/general/","title":"General","text":""},{"location":"faq/general/#how-it-works","title":"Q: How it works","text":"<p>Pyaket is highly inspired by PyApp, with opinionated and idiosyncratic design choices that makes it easier to use and understand, with improved resiliency, speeds, monorepo support, and a cli.</p> <p>In short, the rust language supports build scripts that runs before the compilation of the main program, allowing us to process and pass a configuration from environment variables to the final release. At runtime, download uv and/or a python-distribution archive (or pre-bundle it alongside wheels with rust-embed), create a venv, install dependencies, run the project with incoming argv.</p> <ul> <li>This guarantees maximum compatibility with how the project is run on the user's machine, as we're doing the same steps an experienced python user would do with native tools</li> <li>There is little runtime overhead, mostly checking if the project is already installed and files are properly unpacked, then calling a python interpreter child process</li> </ul> <p>There are a lot of configuration options in the documentation!</p>"},{"location":"faq/windows/","title":"Windows","text":""},{"location":"faq/windows/#antivirus","title":"Q: Virus warnings in Windows Defender or Antivirus","text":"<p>This is a complex topic to explain or not sound suspicious, bear with me - Tremeschin - here.</p> <p> The short answer is to only run executables from trusted sources. There is nothing inherently malicious with my side of the packaging solution - you can read and verify the full source code, in fact, you can destroy my whole carreer<sup>1</sup> if you find something of bad faith in there!</p> <p>Note: I have no control or responsibility over what others use the project for</p> <p>Similar to how a streaming platform or messaging app can't be held responsible for the shared content to an extent, other projects using pyaket (why you're reading this) requires your own judgement and benefit of the doubt.</p>"},{"location":"faq/windows/#antivirus-heuristics","title":"Antivirus heuristics","text":"<p>Out of pure necessity for features to work, like bundling uv, python, script files, wheels, etc. some antivirus heuristics may detect the executables as malicious for a couple of reasons:</p> <ul> <li> <p>Windows and Chrome knows every file you download or execute: A project getting popular or the rush to get a new release can have thousands of downloads pretty quickly. That's a sign of self-replication and fast spread, which will likely get automatically blocked.</p> </li> <li> <p>Better be safe than sorry, if something is half sketchy better avoid it - this is a rule for life too. Microsoft and/or the AV are trying to protect users from their own mistakes, being strong on it as the platform is filled with non-technical users with malware targetting them fair</p> </li> <li> <p>Parts of the compiled rust code can be similar to a known virus, as the language itself can be used to write malware (like any others), which will share many common community libraries source code, such as networking, compression, etc. false positive</p> </li> <li> <p>Pyaket bundles compressed files with code and tools, then calls external programs to install the project and run python. While this is something to always lookout for, as it can be seen as obfuscation or red flags, it's unavoidable for the scope and technology of the project.</p> </li> </ul> <p>Moral of the story, correlation \u2260 causation, trust your sources.</p>"},{"location":"faq/windows/#code-signing","title":"Code signing","text":"<p>How stuff like a browser, a game, steam, discord, etc. don't get flagged?</p> <p>The answer is code signing, similar to how websites gets their <code>https</code> certificate.</p> <p> Essentially, files are \"sealed\" with a digital signature before distribution, while still in a trusted environment from the developer. A certificate authority (like your government) maintains a list of trusted signatures that can be checked against (passports), but if the content differs from the original (fake photo or fingerprint) the signature will be deemed invalid and execution blocked.</p> <p>At its theoretical best, this is a way to gatekeep the bad actors out, as getting a signing certificate is often expensive, easily revoked if misused, requires sensitive information to become public such as address, phone number, legal name, etc. and might not even work properly in the end.</p> <ul> <li> <p>Many Open Source projects struggles due lack of funding, which makes it infeasible to even consider getting a certificate - as it's not an investment with direct returns.</p> </li> <li> <p>Most services that provides free signing for open source projects disallows selling the files, something pyaket advocates for the developer's hard work and paying the bills.</p> </li> </ul> <p>Note: Funnily enough, this is a non-issue on platforms with official package managers such as Linux distributions with educated users - an artificial problem created solely by closed systems.</p> <p> References: (1) (2) (3) (4) </p> <p></p> <ol> <li> <p>Not something particurarly of my interest and professionalism - reductio ad absurdum.\u00a0\u21a9</p> </li> </ol>"},{"location":"get/rust/","title":"Rust","text":"<p>\ud83d\udce6 Pyaket uses the rust programming language for its core functionality.</p> <p>Developing or compiling rust projects requires a toolchain - collection of a compiler, project manager, standard library, and other tools. Luckily, the official installation method rustup manages it all for you, including cross compilation (except for a few external dependencies).</p> <p> All major platforms are supported, though some might be problematic for your project.</p>"},{"location":"get/rust/#native","title":"Native","text":""},{"location":"get/rust/#linux","title":"Linux","text":"<p>Install rustup with the official installation script, or from your package manager:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Ensure you have your Distro's equivalent of a <code>base-devel</code> package installed and/or mingw:</p>  Ubuntu Arch Linux Fedora Debian <pre><code># Native compilation\nsudo apt install build-essential\n\n# Cross compilation\nsudo apt install mingw-w64\n</code></pre> <pre><code># Native compilation\nsudo pacman -Syu base-devel\n\n# Cross compilation\nsudo pacman -Syu mingw-w64-toolchain\n</code></pre> <pre><code># Native compilation\nsudo dnf install gcc\n\n# Cross compilation\nsudo dnf install mingw64-gcc\n</code></pre> <pre><code># Native compilation\nsudo apt install build-essential\n\n# Cross compilation\nsudo apt install mingw-w64\n</code></pre> <p>This script should have added <code>~/.cargo/bin</code> to your <code>PATH</code> environment based on your shell.</p> <p> Note: You may need to restart the terminal to have <code>cargo</code> and <code>rustc</code> available, ensure it.</p>"},{"location":"get/rust/#windows","title":"Windows","text":"<p>Ensure you have Winget installed, open a powershell and run:</p> <pre><code>winget install --id=Rustlang.Rustup -e\n</code></pre> <p>There's two options for a C linker/compiler now,  MinGW or  Visual C++ Build Tools (MSVC).</p> <p> Reason: Rust can't bundle Build Tools due licensing, out of two let the user choose one. Some crates links against system libraries, such as zstd or networking, and need to interface with C.</p> <p>Overall, it's easier to get started with MinGW, which is needed for cross compiling to macOS and Linux anyway. Go with MSVC if you prefer official Microsoft tools or will only target Windows.</p> <p></p>"},{"location":"get/rust/#mingw","title":"MinGW","text":"<p>Download and install MSYS2, a lightweight Linux-like shell and package manager for Windows, in the default location at <code>C:\\msys64</code>.</p> <p>That's it: The python package will auto install dependencies for the platform you're compiling for</p> <p></p>"},{"location":"get/rust/#msvc","title":"MSVC","text":"<p>To avoid any potential confusion, here's a brief clarification on product names:</p> <ul> <li> Visual Studio is a full IDE for C#, C++, .NET development, the original one (purple) #</li> <li> Visual Studio Code is a lightweight code editor with many extensions (blue) #</li> <li> Visual Studio Build Tools is just the compiler, linker for C/C++, without the IDE #</li> </ul> <p>Download and install Build Tools for Visual Studio, enable the following components:</p> <ol> <li>Visual C++ Build Tools</li> <li>Windows 10 SDK</li> <li>Windows 11 SDK</li> </ol> <p>This process can be somewhat reliabily automated by running:</p> PowerShell<pre><code>winget install --id Microsoft.VisualStudio.2022.BuildTools `\n    --override \" `\n        --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 `\n        --add Microsoft.VisualStudio.Component.Windows10SDK `\n        --add Microsoft.VisualStudio.Component.Windows11SDK `\n    \" `\n    --wait --passive\n</code></pre> <p>You should have <code>cl.exe</code>, <code>link.exe</code> and <code>msvc.exe</code> available in your shell.</p>"},{"location":"get/rust/#macos","title":"macOS","text":"<p>Install Homebrew and Xcode, then rustup with:</p> <pre><code>brew install rustup\n</code></pre> <p> Windows cross compilation:</p> <pre><code>brew install mingw-w64\n</code></pre> <p> Linux cross compilation:</p> <pre><code>brew install gcc\n</code></pre> <p></p>"},{"location":"get/rust/#workflows","title":"Workflows","text":""},{"location":"get/rust/#github-actions","title":"GitHub Actions","text":"<p>Runners seem to already have rustup installed by default. Better be safe than sorry though - you can add the following action in your workflow job steps by @dtolnay (unofficial):</p> <pre><code>- name: Install Rust\n  uses: dtol/rust-toolchain@stable\n</code></pre> <p>For compiling Linux ARM binaries, you might need:</p> <pre><code>- name: Install gcc aarch64\n  run: sudo apt install -y gcc-aarch64-linux-gnu\n</code></pre> <p>A full workflow file could look like this:</p> <p>Ensure wider compatibility by compiling with the oldest Linux runner you can get</p> <p>The final binary will only work with the glibc version greater than or equal to the one used to compile it of the host. This is a core part of the Linux ABI, desktop distros are well updated but servers or embedded systems may not be.</p> .github/workflows/make-pyaket.yml<pre><code>name: make-pyaket\n\non:\n  workflow_dispatch:\n\njobs:\n  main:\n    name: Compile on (${{matrix.os}})\n    runs-on: ${{matrix.os}}\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, windows-latest, macos-latest]\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          submodules: recursive\n\n      - name: Setup Rust\n        uses: dtolnay/rust-toolchain@stable\n\n      - name: Install gcc aarch64\n        if: ${{matrix.os == 'ubuntu-22.04'}}\n        run: sudo apt install -y gcc-aarch64-linux-gnu\n\n      - name: Compile projects\n        run: pyaket (...)\n\n      - name: Upload releases\n        uses: actions/upload-artifact@v4\n        with:\n          name: ${{matrix.os}}-release\n          path: release/*\n</code></pre>"}]}